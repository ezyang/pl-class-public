{
  "name": "util-is",
  "author": {
    "name": "Glen R. Goodwin",
    "url": "http://www.arei.net"
  },
  "keywords": [
    "util-is",
    "type",
    "is",
    "util",
    "type safety",
    "safety",
    "types",
    "utils",
    "check",
    "type check",
    "type checking",
    "util is"
  ],
  "description": "Additional Type Check functions for Util",
  "version": "0.1.0",
  "homepage": "http://github.com/arei/util-is",
  "bugs": {
    "url": "http://github.com/arei/util-is/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/arei/util-is/blob/master/LICENSE.txt"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/arei/util-is.git"
  },
  "main": "util-is.js",
  "engines": {
    "node": ">=0.10"
  },
  "dependencies": {},
  "devDependencies": {},
  "optionalDependencies": {},
  "readme": "util-is\r\n-------\r\nAdditional Type Check functions for Util.\r\n\r\nThe node.js util module provides `isArray`, `isDate`, `isRegExp` and `isError`, but forgets about some of the other types in JS.  This is inconsistent and thus poor design.  The `util-is` module serves to bridge that oversight and correct this design flaw by providing `isString`, `isFunction`, `isNumber`, and `isBoolean`.  Additionally it provides some extended behavior such as `isDefined`, `isUndefined`, `isEmpty`, `isObject` and `isPureObject`.\r\n\r\nInstallation\r\n------------\r\nInstall the module via npm and then require it once at the top of your project.  `util-is` modifies the util package such that all copies of util once installed (so long as the installer doesn't do anything tricky like removing util from the modules cache) will be modified with the added functions.\r\n\r\n```\r\n  npm install util-is\r\n```\r\n\r\n```\r\n  require(\"util-is\");\r\n  var util = require(\"util\");\r\n\r\n  util.isString(\"asdf\"); // true\r\n  util.isPureObject(\"asdfasd\"); // false\r\n  util.isPureObject({\r\n    one: 1, \r\n    two: 2\r\n  }); // true\r\n```\r\n\r\nMethods\r\n-------\r\n\r\n### util.isString(o)\r\nGiven some value `o` return true if that value is a string.\r\n\r\n### util.isFunction(o)\r\nGiven some value `o` return true if that value is a function.\r\n\r\n### util.isNumber(o)\r\nGiven some value `o` return true if that value is a number.\r\n\r\n### util.isBoolean(o)\r\nGiven some value `o` return true if that value is a boolean.\r\n\r\n### util.isDefined(o)\r\nGiven some value `o` return true if that value is not undefined.  Technically, null is not undefined therefore, `util.isUndefined(null)` will return true.\r\n\r\n### util.isUndefined(o)\r\nGiven some value `o` return true if that value is undefined.\r\n\r\n### util.isEmpty(o)\r\nGiven some value `o` return true if that value undefined, null, an empty string, an empty array, or an empty object.  It has always annoyed me that JavaScript truthiness did not recognize [] as false and {} as false.  `util.isEmpty(o)` rectifies that.\r\n\r\n### util.isPureObject(o)\r\nGiven some value `o` return true if the given value is not undefined, not null, not an array, not a string, not a number, not a boolean, not a function, not a RegExp, not an Error, and note a Date.  Basically, if the given object does not inherit from one of the core types, this return true.\r\n\r\n",
  "readmeFilename": "README.md",
  "_id": "util-is@0.1.0",
  "_from": "util-is@~0.1.0"
}
