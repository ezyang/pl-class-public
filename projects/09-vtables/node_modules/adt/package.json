{
  "name": "adt",
  "version": "0.7.2",
  "author": {
    "name": "Nathan Faubion",
    "email": "nathan@n-son.com"
  },
  "description": "Algebraic data types for Javascript",
  "scripts": {
    "test": "mocha -u tdd"
  },
  "main": "./adt",
  "repository": {
    "type": "git",
    "url": "https://github.com/natefaubion/adt.js.git"
  },
  "keywords": [
    "algebraic",
    "data",
    "types",
    "functional",
    "case",
    "classes"
  ],
  "devDependencies": {
    "mocha": "*",
    "uglify-js": "1.3.x",
    "sweet.js": "*"
  },
  "license": "MIT",
  "readme": "adt.js\n======\n\nAlgebraic data types and immutable structures for Javascript.\n\nFeatures\n--------\n\nadt.js gives you the following for free:\n\n* Immutablity\n* Type-checking attributes\n* Deep equality and cloning\n* Curried constructors\n* `toString` and `toJSON` implementations\n* Enums\n* [Sweet.js](https://github.com/mozilla/sweet.js) macros\n\nInstall\n-------\n\n`npm install adt`\n\nBasic Usage\n-----------\n\nLet's start by creating a simple `Maybe` ADT for possible failure:\n\n**JS:**\n``` js\nvar adt = require('adt');\nvar Maybe = adt.data({\n  Nothing: null,\n  Just: { value: adt.any }\n});\n```\n\n**CS:**\n```coffee\n{data, any, only} = require 'adt'\nMaybe = data\n  Nothing : null\n  Just :\n    value : any\n```\n\n**Macros:**\n``` js\ndata Maybe {\n  Nothing,\n  Just {\n    value: *\n  }\n}\n```\n`adt.any` is a value constraint that will allow anything. If you wanted to\nrestrict the type, you could use `adt.only`.\n\nHere's how you might use our new data type:\n\n```js\nvar noth = Maybe.Nothing;\nvar just = Maybe.Just(42);\n\n// Inheritance\n(just instanceof Maybe.Just) === true;\n(just instanceof Maybe) === true;\n\n// Type-checking\njust.isNothing === false;\njust.isJust === true;\n\n// Record attributes\njust.value === 42;\n\n// Immutablity: `set` returns a new instance\nvar just2 = just.set({ value: 43 });\njust !== just2;\n\n// Retrieve values by name or by index\njust.get('value') === 42;\njust.get(0) === 42;\njust.get(1); // Error: Out of range\n\n// `toString` implementation\njust.toString() === 'Just(42)';\n```\n\nSince `Nothing` is not a record (it doesn't have any data attributes), it\nexists as a singleton instance and does not need to be instanciated.\n\nRecursive Types\n---------------\n\nLet's define a linked-list type:\n\n**JS:**\n```js\nvar adt = require('adt');\nvar List = adt.data(function () {\n  return {\n    Nil: null,\n    Cons: {\n      head: adt.any,\n      tail: adt.only(this)\n    }\n  };\n});\n```\n\n**CS:**\n```coffee\n{data, any, only} = require 'adt'\nList = data ->\n  Nil : null\n  Cons :\n    head : any\n    tail : only this\n```\n\n**Macros:**\n```js\ndata List {\n  Nil,\n  Cons {\n    head: *,\n    tail: List\n  }\n}\n```\n\nNote that we've introduced a lambda to house our definition. With our `Maybe`\ntype this wasn't necessary, because we didn't need to reference the ADT itself.\nBut here, we want to use `adt.only` to put a constraint on the value of `tail`\nso it can only contain `List` types. If we left out the lambda and just used\nthe object literal syntax, `List` wouldn't exist when we try to pass it to\n`adt.only` and we'd get a `ReferenceError`. See the end of this document for\nan alternative that does not require a lambda.\n\nAnd now let's put it to good use:\n\n```js\nvar list = List.Cons(12, List.Cons(42, List.Nil));\n\n// Record attributes\nlist.head === 12;\nlist.tail.toString() === 'Cons(42, Nil)';\n\n// Deep equality\nvar list2 = List.Cons(42, List.Nil);\nlist.tail.equals(list2) === true;\n\n// Instanciate with key/value pairs\nList.Cons.create({\n  head: 42,\n  tail: List.Nil\n});\n\n// Curried constructor\nvar consPartial = List.Cons(12);\nvar list3 = consPartial(List.Nil);\n\n// Constraints\nList.Cons(42, 12) // TypeError!\n```\n\nEnums\n-----\n\nLet's define a simple days-of-the-week enum using `adt.enumeration` or its\nalias `adt.enum`:\n\n**JS:**\n```js\nvar Days = adt.enum('Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat');\n```\n\n**Macros:**\n```js\nenum Days {\n  Sun, Mon, Tues, Wed, Thur, Fri, Sat\n}\n```\n\nEnums can be compared using `lt`, `lte`, `eq`, `gte`, and `gt`.\n\n```js\nvar day1 = Days.Tues;\nvar day2 = Days.Fri;\n\nday1.lt(day2) === true;\nday2.gt(day1) === true;\nday1.eq(Days.Mon) === false;\n```\n\nEnums can also have constant values for JSON serialization:\n\n**JS:**\n```js\nvar Days2 = adt.enum({\n  Sun  : 1,\n  Mon  : 2,\n  Tues : 3,\n  Wed  : 4,\n  Thur : 5,\n  Fri  : 6,\n  Sat  : 7\n});\n\n// Our previous definition serializes everything to null.\nDays.Mon.toJSON() === null;\n\n// But our new one serializes to an integer.\nDays2.Mon.toJSON() === 2;\n```\n\n**Macros:**\n```js\nenum Days2 {\n  Sun = 1,\n  Mon = 2,\n  Tues = 3,\n  // ...etc\n}\n```\n\nNote that the value you give it does not affect the comparison methods. That\nis determined solely by insertion order.\n\nEnums aren't really special. They are just normal ADTs with some extra\nbehavior. You are not restricted to only using singleton types like we did\nabove. You could just as easily have an enum of record types too. Likewise, you\ncan also give a value to any singleton type. `null` is just the default value\nand often times a good representation of the type (Nothing, Nil, Empty, etc).\n\nNewtypes\n--------\n\nSometimes you just need a type that exists by itself. Use `adt.newtype` as\na shortcut:\n\n**JS:**\n```js\n// Instead of this:\nvar Lonely = adt.data({\n  Lonely: {\n    value: adt.any\n  }\n});\nLonely = Lonely.Lonely;\n\n// Do this:\nvar Lonely = adt.newtype('Lonely', {\n  value: adt.any\n});\n```\n\n**Macros:**\n```js\nnewtype Lonely {\n  value: *\n}\n```\n\nConstraints\n-----------\n\nadt.js has two builtin value constraints: `any`, to represent the lack of a\nconstraint, and `only`, to restrict a value to certain types.\n\n```js\n// `any` is an id function\nadt.any(12) === 12;\nadt.any('Foo') === 'Foo';\n\n// Only is a constraint factory\nvar onlyNumbers = adt.only(Number);\nvar onlyStrings = adt.only(String);\nvar onlyPrimitives = adt.only(Number, String, Boolean);\n\nonlyNumbers(12) === 12;\nonlyStrings('Foo') === 'Foo';\nonlyPrimitives(/^$/); // TypeError!\n```\n\nConstraints are just functions that take a value and return another or throw an\nexception.\n\n```js\nfunction toString (x) { \n  return x.toString();\n};\n\nvar OnlyStrings = adt.newtype({\n  value: toString\n});\n\nOnlyStrings(12).value === '12';\n```\n\nSealing Your ADT\n----------------\n\nAll ADTs are left \"open\" by default, meaning you can add types and fields to it\nat a later time. You can close your ADT by calling `seal`.\n\n```js\nvar Maybe = adt.data();\nvar Nothing = Maybe.type('Nothing');\nvar Just = Maybe.type('Just', { value: adt.any });\n\n// Close it.\nMaybe.seal();\n\n// Calling `type` results in an error\nMaybe.type('Foo'); // Error!\n```\n\nObject Literal Insertion Order\n------------------------------\n\nAstute readers might notice that adt.js relies on a controversial feature: the \nhost engine maintaining insertion order of keys in object literals. It's true\nthat the Javascript spec does not require this feature. However, it has become\na defacto standard, and all engines implement this feature for the string keys\nwe are using.\n\nadt.js also offers a \"safe\" API that does not rely on this feature:\n\n```js\nvar List = adt.data(function (type, List) {\n  type('Nil', null);\n  type('Cons', adt.record(function (field) {\n    field('head', adt.any);\n    field('tail', adt.only(List));\n  }));\n});\n```\n\nIn fact, this is just the desugared form of the terse API. See the end of this\ndocument for an alternative that uses chaining instead of lambdas and closures.\n\nImmutability\n------------\n\nJavascript is inherently mutable, and so adt.js can't guarantee immutablity,\nonly facilitate it. By using `set` instead of direct attribute assignment, we\nget safe, immutable structures. But if we were to store say an object literal\nas a value, we could certainly get a reference to it and mutate it, affecting\nany data that might be sharing it.\n\n```js\nvar obj = { foo: 'bar' };\nvar just1 = Just(obj);\nvar just2 = Just(obj);\n\n// Bad!\njust1.value.foo = 'baz';\njust2.value.foo === 'baz';\n```\n\nDeep Equality\n-------------\n\nadt.js only performs deep equality on adt.js types. It does not perform deep\nequality on native arrays or objects. Anything that is not an adt.js type is\ncompared using strict equality (`===`).\n\n```js\nvar arr = [1, 2, 3];\nvar just1 = Just(arr);\nvar just2 = Just(arr);\n\njust1.equals(just2) === true;\njust1.equals(Just([1, 2, 3])) === false;\n```\n\nIf you would like to extend this behavior, you can override the default method\nfor equality on native JS types. For example, if you were using lodash:\n\n```js\n// Deep equality on all native JS types (Objects, Arrays, RegExps, Dates, etc.)\nadt.nativeEquals = _.isEqual;\n```\n\nCloning\n-------\n\nadt.js types all have a `clone` method for returning a safe copy of a data\nstructure. As with deep equality, it only clones adt.js types and copies arrays\nand objects by reference. Singleton instances will always return the same\ninstance when copied.\n\n```js\nvar just1 = Just(42);\nvar just2 = just.clone();\n\njust2.value === 42;\njust1 !== just2;\n```\n\nAs with equality, you can extend the default cloning behavior for native JS\ntypes. Using lodash:\n\n```js\nadt.nativeClone = _.cloneDeep;\n```\n\nOverriding `apply`\n------------------\n\nFor some types, it can be nice to have some sugar on the parent type. For\nexample, it would be nice if you could build a `List` like you would an\n`Array`:\n\n```js\nvar arr = Array(1, 2, 3);\n\n// Wouldn't this be nice?\nvar list = List(1, 2, 3);\nlist.toString() === 'Cons(1, Cons(2, Cons(3, Nil)))';\n```\n\nadt.js detects when you override your `apply` method and can use that to\ncreate your types.\n\n```js\nList.apply = function (ctx, args) {\n  // Hypothetical `fromArray` function\n  return List.fromArray(args);\n};\n```\n\nPattern Matching\n----------------\n\nData types made with adt.js have builtin support for sparkler, a pattern\nmatching engine for JavaScript:\n\n```js\ndata Tree {\n  Empty,\n  Node {\n    value: *,\n    left: Tree,\n    right: Tree\n  }\n}\n\nfunction treeFn {\n  case Empty => 'empty'\n  case Node(42, ...) => '42'\n  case Node{ left: Node(12, ...) } => 'left 12'\n}\n```\n\nFind out more about sparkler: https://github.com/natefaubion/sparkler\n\nAPI Variety\n-----------\n\nadt.js has a versatile API, so you can define your types in a way that suits\nyou. Some ways are very terse, while others are \"safer\" (don't rely on object\ninsert order).\n\nIf you don't like defining recursive types within a function, you might like:\n\n```js\nvar List = adt.data();\nvar Nil  = List.type('Nil');\nvar Cons = List.type('Cons', {\n  head: adt.any,\n  tail: adt.only(List)\n});\n```\n\nThis has the advantage of shaving off a few lines but requires some name\nduplication.\n\nAnother way of defining \"safe\" types is to use chaining instead of a closure:\n\n```js\nvar List = adt.data();\nvar Nil  = List.type('Nil');\nvar Cons = List.type('Cons', {})\n             .field('head', adt.any)\n             .field('tail', adt.only(List));\n```\n\nDepending on you needs, there should hopefully be an easy, terse way of\ndefining your types.\n\nUsing Macros\n------------\n\n```\nnpm install -g sweet.js\nnpm install adt\nsjs -m adt/macros myfile.js\n```\n\nIn your file you don't need to `require('adt')`. The macro will load it for\nyou when you define a data type.\n\nOne nice property of the macros is that the data constructors are automatically\nbrought into the surrounding scope:\n\n```js\ndata List {\n  Nil,\n  Cons {\n    head: *,\n    tail: List\n  }\n}\n\n// Nil and Cons are in scope.\nvar list = Cons(42, Cons(12, Nil));\n```\n\nWhen declaring your constraints, the macros try to \"do the right thing\". If the\nidentifier for the constraint starts with an upper-case letter, it will use an\n`adt.only` constraint. If it starts with a lower-case letter, it will use it\nas is. You can also inline a function literal as a constraint.\n\n---\n\n### Author\nNathan Faubion (@natefaubion)\n\n### License\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/natefaubion/adt.js/issues"
  },
  "_id": "adt@0.7.2",
  "_from": "adt@~0.7.2"
}
